#!/usr/bin/perl
use strict;
use warnings;
use Switch;
use File::stat;
use Socket;
use POSIX qw(:sys_wait_h :errno_h);

my $pidfilepath = "/tmp/comanche.pid";
my $configfilepath = "comanche.conf";
my %httpcodes = (
    200 => "OK",
    400 => "Bad Request",
    403 => "Forbidden",
    404 => "Not Found",
    405 => "Method Not Allowed",
    415 => "Unsupported Media Type",
    418 => "I'm a teapot",
    503 => "Service Unavailable",
    505 => "HTTP Version Not Supported"
);
my @months = ("Jan", "Feb", "Mar", "Apr", "May", "Jun",
              "Jul", "Aug", "Sep", "Oct", "Nov", "Dec");
my @days = ("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun");
my @ouvriers = ();

sub superviseur {
    # Journalisation
    my %config = load_config();
    open(my $fh, '>>', $config{'logfile'} ) or die "Impossible d'ouvrir $config{logfile}: $!";
    autoflush $fh 1;
    $SIG{QUIT} = sub {
        print $fh time, ";stop;local;", $config{"port"}, ";;;\n";
    	close $fh;
    	exit;
    };
    print $fh $_ while <STDIN>;
}

sub repartisseur {
    # Répartisseur de requêtes
    my $request_count = 0;
    my %config = load_config();
    my $LOGGER;
    my $loggerpid = open($LOGGER, "|-");
    if ($loggerpid == 0) {
        superviseur();
        exit;
    } else {
        # Signal pour le statut du serveur
        $SIG{USR1} = sub {
            print "PID ", $$, "\n";
            print $request_count, " requêtes traitées depuis le démarrage\n";
            print $#ouvriers + 1, " ouvriers : ", join(" ", @ouvriers), "\n";
        };
        # Signal d'arrêt du serveur
        $SIG{QUIT} = sub {
            foreach (@ouvriers) {
                kill 'QUIT', $_;
            }
            kill 'QUIT', $loggerpid;
            1 while(waitpid(-1, WNOHANG) > 0);
            exit;
        };
        $SIG{CHLD} = "rest_in_pieces";
        autoflush $LOGGER 1;
        socket(my $SRV, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
        setsockopt($SRV, SOL_SOCKET, SO_REUSEADDR, 1);
        my $ip = sockaddr_in($config{"port"}, INADDR_ANY);
        bind($SRV, $ip) or die "Erreur au démarrage du serveur : $!";
        listen($SRV, SOMAXCONN) or die "Erreur au démarrage du serveur : $!";
        print $LOGGER time, ";start;local;", $config{"port"}, ";;;\n";
        while(1) {
            accept(my $CLIENT, $SRV);
            next if($!{EINTR});
            if($#ouvriers >= $config{"clients"}) {
                send_error($CLIENT, 503);
                next;
            }
            my $pid = fork;
            if ($pid != 0) {
                push @ouvriers, $pid;
            } else {
                ouvrier($CLIENT, $LOGGER);
                exit;
            }
        }
    }
}

sub ouvrier {
    # Traitement d'une requête
    my $CLIENT = shift;
    my $LOGGER = shift;
    my ($method, $path, $version) = split /\s/, <$CLIENT>, 3;
    if($version !~ /HTTP\/1.1/) {
        send_error($CLIENT, 505); exit;
    }
    if($method ne "GET") {
        send_error($CLIENT, 405); exit;
    }
    # TODO: Gestion des projections et logging
    print $LOGGER time, ";;;;;;", "\n";
    send_error($CLIENT, 404); exit;
}

sub load_config {
	my %config = ();
	open( my $fh, '<', $configfilepath ) or die "Impossible d'ouvrir $configfilepath: $!";
	while (my $row = <$fh>) {
	  chomp $row;
	  if($row =~ /^set\s+(.+)\s+(.*)$/){
	  	$config{$1} = $2;
	  }
	}
	close $fh;
    if(!-e $config{'error'}) { die "$!"; }
	return %config;
}

sub send_response_headers {
    # Envoyer les headers de réponse HTTP au client
    my $CLIENT = shift;
    my $code = shift;
    my $length = shift;
    my $type = shift;
    print $CLIENT "HTTP/1.1 ", $code, " ", $httpcodes{$code}, "\r\n";
    my ($sec, $min, $hour, $day, $month, $year, $weekday) = gmtime();
    print $CLIENT sprintf("Date: %s, %02d %s %04d %02d:%02d:%02d GMT\r\n", $days[$weekday], $day, $months[$month], 1900 + $year, $hour, $min, $sec);
    print $CLIENT "Server: comanche/1.0\r\n";
    print $CLIENT "Content-Length: $length\r\n";
    print $CLIENT "Content-Type: $type\r\n\r\n";
}

sub send_error {
    # Envoyer une erreur HTTP au client
    my %config = load_config();
    my $client = shift;
	my $errorcode = shift;
    send_response_headers($client, $errorcode, stat($config{'error'})->size, "text/html");
    open( my $fh, '<', $config{'error'} ) or die "Impossible d'ouvrir $config{'error'}: $!";
    print $client $_ while(<$fh>);
    close($fh);
    close($client);
}

sub rest_in_pieces {
    # Adresse les condoléances aux familles des ouvriers.
    while ((my $corpsepid = waitpid(-1, &WNOHANG)) > 0) {
        @ouvriers = grep { $_ != $corpsepid } @ouvriers;
    }
};

sub get_repartisseur_pid {
    # Obtenir l'ID du processus de répartisseur
    open my ($pidfile), $pidfilepath or die "Impossible d'obtenir l'ID du processus serveur";
    my $reppid = <$pidfile>;
    close $pidfile;
    return $reppid;
}

if($#ARGV == 0) {
    switch (lc $ARGV[0]) {
        case 'start' {
            # Démarrage du serveur
            my $pid = fork;
            if ($pid == 0) {
                repartisseur();
                exit;
            } else {
                open my ($pidfile), '>', $pidfilepath or die "Impossible d'enregistrer le PID serveur";
                print $pidfile $pid, "\n";
                close $pidfile;
                exit;
            }
        }
        case 'stop' {
            # Arrêt propre du serveur
            my $id = get_repartisseur_pid();
            kill 'QUIT', $id;
            unlink $pidfilepath;
            exit;
        }
        case 'status' {
            # État du serveur
            kill 'USR1', get_repartisseur_pid();
            exit;
        }
    }
}
print STDERR "Usage: comanche (start|stop|status)\n";
