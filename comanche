#!/usr/bin/perl
use strict;
use warnings;
use Switch;
use Socket;

my $pidfilepath = "/tmp/comanche.pid";

sub superviseur {
    # Journalisation
    # TODO
}

sub repartisseur {
    # Répartisseur de requêtes
    my $request_count = 0;
    my @ouvriers = ();
    my %config = load_config;
    my $loggerpid = open(LOGGER, "|-");
    if ($loggerpid == 0) {
        exit superviseur(LOGGER);
    } else {
        # Signal pour le statut du serveur
        $SIG{USR1} = sub {
            print "PID ", $$, "\n";
            print $request_count, " requêtes traitées depuis le démarrage\n";
            print $#ouvriers + 1, " ouvriers : ", join(" ", @ouvriers), "\n";
        };
        # Signal d'arrêt du serveur
        $SIG{QUIT} = sub {
            foreach (@ouvriers) {
                kill 'QUIT', $_;
            }
            kill 'QUIT', $loggerpid;
            exit;
        };
        autoflush LOGGER 1;
        socket(SRV, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
        setsockopt(SRV, SOL_SOCKET, SO_REUSEADDR, 1);
        $ip = sockaddr_in($config{"port"}, INADDR_ANY);
        bind(SRV, $ip) or die "Erreur au démarrage du serveur : $!";
        listen(SRV, $config{"clients"}) or die "Erreur au démarrage du serveur : $!";
        print LOGGER time, ";start;local;", $config{"port"}, ";;;";
        while(accept(CLIENT, SRV)) {
            if($#ouvriers >= $config{"clients"}) {
                send_error(CLIENT, "503");
                next;
            }
            $pid = fork;
            if ($pid != 0) {
                push @ouvriers $pid;
            } else {
                ouvrier(CLIENT);
            }
        }
    }
}

sub ouvrier {
    # Traitement d'une requête
    # TODO
}

sub load_config {
    # Chargement de la configuration du serveur
    # TODO
}

sub send_response {
    # Envoyer une réponse HTTP au client
    # TODO
}

sub send_error {
    # Envoyer une erreur HTTP au client
    # TODO
}

sub get_repartisseur_pid {
    # Obtenir l'ID du processus de répartisseur
    open my ($pidfile), $pidfilepath or die "Impossible d'obtenir l'ID du processus serveur";
    my $reppid = <$pidfile>;
    close $pidfile;
    return $reppid;
}

if($#ARGV == 0) {
    switch (lc $ARGV[0]) {
        case 'start' {
            # Démarrage du serveur
            my $pid = fork;
            if ($pid == 0) {
                exit repartisseur();
            } else {
                open my ($pidfile), '>', $pidfilepath or die "Impossible d'enregistrer le PID serveur";
                print $pidfile $pid, "\n";
                close $pidfile;
                exit;
            }
        }
        case 'stop' {
            # Arrêt propre du serveur
            my $id = get_repartisseur_pid();
            kill 'QUIT', $id;
            exit;
        }
        case 'status' {
            # État du serveur
            kill 'USR1', get_repartisseur_pid();
            exit;
        }
    }
}
print STDERR "Usage: comanche (start|stop|status)\n";
